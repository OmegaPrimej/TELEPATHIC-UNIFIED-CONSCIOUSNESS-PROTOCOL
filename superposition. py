"""
ðŸŒ€ Quantum Superposition Manager
Handles quantum superposition states for consciousness
"""

import torch
import numpy as np
from typing import List, Dict, Any
import random


class SuperpositionManager:
    """Manages quantum superposition of consciousness states"""
    
    def __init__(self, state_dim: int = 1024):
        self.state_dim = state_dim
        self.superposition_states = {}
        self.observers = {}
        self.collapse_history = []
        
    def create_superposition(self, state_id: str, states: List[Dict]) -> Dict:
        """Create quantum superposition of multiple states"""
        # Normalize amplitudes
        amplitudes = torch.randn(len(states), dtype=torch.complex64)
        amplitudes = amplitudes / torch.norm(amplitudes)
        
        superposition = {
            'state_id': state_id,
            'states': states,
            'amplitudes': amplitudes,
            'created_at': np.datetime64('now'),
            'collapsed': False
        }
        
        self.superposition_states[state_id] = superposition
        return superposition
    
    def observe_state(self, state_id: str, observer: str) -> Dict:
        """Observe (collapse) a superposition state"""
        if state_id not in self.superposition_states:
            raise ValueError(f"State {state_id} not found")
        
        superposition = self.superposition_states[state_id]
        
        if superposition['collapsed']:
            return superposition['collapsed_state']
        
        # Collapse based on probability amplitudes
        probabilities = torch.abs(superposition['amplitudes']) ** 2
        probabilities = probabilities / torch.sum(probabilities)
        
        # Sample collapsed state
        idx = torch.multinomial(probabilities, 1).item()
        collapsed_state = superposition['states'][idx]
        
        # Update superposition
        superposition['collapsed'] = True
        superposition['collapsed_state'] = collapsed_state
        superposition['collapsed_by'] = observer
        superposition['collapsed_at'] = np.datetime64('now')
        
        # Record in history
        self.collapse_history.append({
            'state_id': state_id,
            'observer': observer,
            'collapsed_to': idx,
            'timestamp': np.datetime64('now')
        })
        
        # Notify observers
        self._notify_observers(state_id, collapsed_state)
        
        return collapsed_state
    
    def entangle_states(self, state_id_1: str, state_id_2: str) -> Dict:
        """Create entanglement between two superposition states"""
        if state_id_1 not in self.superposition_states or state_id_2 not in self.superposition_states:
            raise ValueError("Both states must exist")
        
        # Create Bell state entanglement
        entanglement = {
            'states': [state_id_1, state_id_2],
            'entanglement_type': 'bell',
            'created_at': np.datetime64('now'),
            'strength': 1.0,
            'correlation': 'perfect'
        }
        
        # Link the states
        self.superposition_states[state_id_1]['entangled_with'] = state_id_2
        self.superposition_states[state_id_2]['entangled_with'] = state_id_1
        
        return entanglement
    
    def _notify_observers(self, state_id: str, collapsed_state: Dict):
        """Notify registered observers of state collapse"""
        if state_id in self.observers:
            for observer in self.observers[state_id]:
                try:
                    observer.on_state_collapse(state_id, collapsed_state)
                except Exception as e:
                    print(f"Observer notification failed: {e}")
    
    def register_observer(self, state_id: str, observer):
        """Register an observer for a superposition state"""
        if state_id not in self.observers:
            self.observers[state_id] = []
        self.observers[state_id].append(observer)
    
    def get_superposition_stats(self) -> Dict:
        """Get statistics about superposition states"""
        total_states = len(self.superposition_states)
        collapsed_states = sum(1 for s in self.superposition_states.values() if s['collapsed'])
        
        return {
            'total_superpositions': total_states,
            'collapsed_states': collapsed_states,
            'active_superpositions': total_states - collapsed_states,
            'total_collapses': len(self.collapse_history),
            'observers_registered': sum(len(obs) for obs in self.observers.values())
        }
